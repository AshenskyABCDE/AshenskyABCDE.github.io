<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="快快乐乐就好了">
<meta property="og:type" content="website">
<meta property="og:title" content="zjb的日常分享">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="zjb的日常分享">
<meta property="og:description" content="快快乐乐就好了">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="喜欢acm的zjb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>zjb的日常分享</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zjb的日常分享</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/24/%E6%88%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://picx.zhimg.com/v2-ff1f54ea1c0258b284145044aafd19a2_l.jpg?source=32738c0c">
      <meta itemprop="name" content="喜欢acm的zjb">
      <meta itemprop="description" content="快快乐乐就好了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjb的日常分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/24/%E6%88%91/" class="post-title-link" itemprop="url">我</a>
        </h2>

        <div class="post-meta">
          
          <i class="fa fa-thumb-tack"></i>
          <font color=7D26CD>置顶</font>
          <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-24 15:52:03 / 修改时间：16:06:19" itemprop="dateCreated datePublished" datetime="2022-11-24T15:52:03+08:00">2022-11-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我叫zjb，目前本科就读于哈尔滨的东北林业大学，暂时是大二的学生，是一位算法爱好者但是icpc上目前只有一块铜牌。很喜欢分享自己的心得，喜欢广交朋友。如果你对我感兴趣的话，欢迎加我的QQ：251902756</p>
<p>技术栈：C++&#x2F;hadoop Spark 数据分析&#x2F;python&#x2F;一点点前端&#x2F;一点点算法</p>
<p>暂时想学的：C++&#x2F;python&#x2F;数据库&#x2F;深度学习</p>
<p>现在想写点项目，学学c++&#x2F;python，同时算法也不要落下。</p>
<p>然后就算吃好玩好，和朋友们开开心心的</p>
<h2 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h2><p>我觉得大家都是一样的，尊重并喜欢每一个人。有很多次，自己的想法总是被人误解，特别是简单的分享被对方认为是找话题搭讪，其实挺伤心易冷的。</p>
<p>现在觉得不认识的人，我就应该是不认识的态度，对待朋友再热心肠吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://picx.zhimg.com/v2-ff1f54ea1c0258b284145044aafd19a2_l.jpg?source=32738c0c">
      <meta itemprop="name" content="喜欢acm的zjb">
      <meta itemprop="description" content="快快乐乐就好了">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zjb的日常分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">字符串笔记</a>
        </h2>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-24 15:55:04 / 修改时间：16:00:17" itemprop="dateCreated datePublished" datetime="2022-11-24T15:55:04+08:00">2022-11-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="string-专题"><a href="#string-专题" class="headerlink" title="string 专题"></a>string 专题</h1><h2 id="0-目录："><a href="#0-目录：" class="headerlink" title="0.目录："></a>0.目录：</h2><p>1.hash </p>
<p>2.最小表示法</p>
<p>3.manacher</p>
<p>4.kmp</p>
<p>5.exkmp</p>
<p>6.trie树</p>
<p>7.AC自动机</p>
<p>8.后缀数组</p>
<p>9.后缀数组自动机</p>
<p>10.字符串dp</p>
<p>11.回文自动机</p>
<h2 id="1-hash"><a href="#1-hash" class="headerlink" title="1.hash"></a>1.hash</h2><p>利用构造的式子来判断某个字符串是否实现，合理的构造会使得hash冲突减小</p>
<p>比如说 构造 abc&#x3D;123 bc&#x3D;14 d&#x3D;114514，就可以用判断数字的方式判断字符串的一些问题（比如出现次数等)</p>
<p>这个专题其实要说的很多，但是都是差不多的。构造方式一般是Pi&#x3D;Pi-1*base+x 鉴于牛客卡过单哈希，我觉得还是尽量写双哈希，甚至五哈希！</p>
<p>关于哈希没有什么很好玩的东西，大多数都是判重复或者回文</p>
<h2 id="2-最小表示法"><a href="#2-最小表示法" class="headerlink" title="2.最小表示法"></a>2.最小表示法</h2><p>定义S 中：S[i,n] +S[1,i-1]&#x3D;T 且 	T&#x3D;S，那么我们说T与S是循环构造，其中字典序最小的T即是最小表示法</p>
<p>（主要借鉴 oi wiki）</p>
<p>首先最坏的算法是n方的暴力枚举，即枚举起点与终点</p>
<p>因此可以利用类似于双指针的思想，用i和j去枚举两种不同的字符串，然后再用k去模拟两种不同长度的字符串的情况。再次之中比较两种字符串，把字典序大的删去，剩下的就是答案。这个方法其实是n方的优化，实际上如果aaaaaa….aab这种数据 依然会被卡成n方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[(i+k)%n]==s[(j+k)%n])&#123;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[(i+k)%n]&gt;s[(j+k)%n])&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==j)i++;</span><br><span class="line">	k=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i=<span class="built_in">min</span>(i,j);</span><br></pre></td></tr></table></figure>

<p>考虑优化：</p>
<p>1.对于s[i,i+k]与s1[j,j+k]而言 如果一个被删去，[i，i+k]里面实际上不可能会有答案（如果有更优答案，一定被判断过）</p>
<p>那不妨每次更新的时候 直接让删去的位置i 变成 i+k+1 </p>
<p>2.当两种字符串逐个相等的时候，不需要再将k清零，接着比就行。只有删去一个字符串，寻找另外一种字符串进行匹配的时候，再将长度k清零。</p>
<p>以上 就可以把n方优化成近似o（n）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[(i+k)%n]==s[(j+k)%n])&#123;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[(i+k)%n]&gt;s[(j+k)%n])&#123;</span><br><span class="line">		i=i+k+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==j)i++;</span><br><span class="line">		k=<span class="number">0</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		j=j+k+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i==j)i++;</span><br><span class="line">		k=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">i=<span class="built_in">min</span>(i,j);</span><br></pre></td></tr></table></figure>



<h2 id="3-manacher（马拉车算法）"><a href="#3-manacher（马拉车算法）" class="headerlink" title="3.manacher（马拉车算法）"></a>3.manacher（马拉车算法）</h2><p>用处：求最大回文子串长度</p>
<p>优点：可以以较短的代码比较方便的解决问题</p>
<p>缺点：只能运用在这一个问题，而二分+哈希 也能求解相应问题</p>
<p>思考一下回文字符长度为奇数以及回文字符长度为偶数的时候：</p>
<p>a a   	a a a </p>
<p>可以发现偶数的对称中心对应是空的，而奇数的对称中心有对应的字符。因此在计算偶数的回文时会有一些麻烦，因此不如将</p>
<p>字符串构造成只含有奇数字符</p>
<p>很简单，第0位填&amp;，第一位填^，之后填一个原字符再填一个^即可</p>
<p>例如 ：$^a^b^c^d^  并通过观察可得，构造完 某位的回味半径r即为原半径+1</p>
<p>我们需要记录的是：p[i]（某位所对应的回文半径），maxr（之前回文统计右边所能达到的最远距离），mid也就是maxr最大时的中心</p>
<p>注意的是maxr开区间闭区间都是可以的，看个人习惯，因而在不同的manacher题解上，会出现+1等微小差别，但思想核心一样)</p>
<p><img src="https://img2022.cnblogs.com/blog/1667561/202204/1667561-20220404110300906-1580231129.png"></p>
<p>像这样记录一下之前字符串所对应的最大右边界</p>
<p>此时我们来考虑i 在区间内的两种情况，即为i&lt;&#x3D;maxr</p>
<p><img src="https://img2022.cnblogs.com/blog/1667561/202204/1667561-20220404110315687-298811278.png"></p>
<p>我们不难发现，在这个大区间中，存在着一个点j关于mid与i对称。因为mid&#x3D;（i+j）&#x2F;2，因此j&#x3D;2*mid-i</p>
<p>并且如果i+p[j]&lt;&#x3D;maxr 的话，p[i]&#x3D;p[j]（因为是严格对称的，如果当前大区间是对称区间，那么i和j的回文区间半径也一定相同）</p>
<p>此时的第二种情况:i+p[j]&gt;maxr （同时证明 p[i]&lt;&#x3D; maxr-i）</p>
<p><img src="https://img2022.cnblogs.com/blog/1667561/202204/1667561-20220404110325744-474473662.png"></p>
<p>由于之前所确定的R最远的区间已经确定，那么上图中黄色区域一定是不相等的，因为如果相等，maxr就不是之前的位置，应当是紫色的那个最远位置。因此我们可以确定，p[i]&lt;&#x3D;maxr-i。</p>
<p>综上所述，如果i在之前统计的大区间中，p[i]一定&gt;&#x3D;min(p[mid * 2-i] ,  maxr-i)，因此可以直接让p[i]&#x3D;min（p[mid * 2-i],maxr-i）</p>
<p>之后while(s[i+p[i]]&#x3D;&#x3D;s[i-p[i]])p[i]++，来更新i的半径大小</p>
<p>最后如果r大于maxr 则将maxr以及mid进行更新即可。</p>
<p>总结：1.根据之前R最远的区间来赋予p[i]</p>
<p>2.暴力更新p[i]的值</p>
<p>3.如果R比之前的maxr大，则更新区间的新信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>]=<span class="string">&#x27;&amp;&#x27;</span>,s[<span class="number">1</span>]=<span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">	cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		s[cnt]=s1[i];</span><br><span class="line">		cnt++;</span><br><span class="line">		s[cnt]=<span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxr=<span class="number">0</span>,mid=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=maxr)&#123;</span><br><span class="line">			p[i]=<span class="built_in">min</span>(p[mid*<span class="number">2</span>-i],maxr-i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(s[i+p[i]]==s[i-p[i]])&#123;</span><br><span class="line">			p[i]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i+p[i]&gt;maxr)&#123;</span><br><span class="line">			maxr=i+p[i];</span><br><span class="line">			mid=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>[P1659 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1659">国家集训队]拉拉队排练</a> 不错的入门题</li>
<li>[P3501 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3501">POI2010]ANT-Antisymmetry</a> 比较裸</li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA11475">UVA11475 Extend to Palindrome</a> 需要稍微想一想</li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6216">P6216 回文匹配</a> 统计答案十分精妙</li>
<li>[P4555 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4555">国家集训队]最长双回文串</a> 回文树可做，但是思考 O(n)<em>O</em>(<em>n</em>) 做法大有裨益。</li>
<li>[P5446 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5446">THUPC2018]绿绿和串串</a> Manacher 好题</li>
</ul>
<h2 id="4-kmp算法"><a href="#4-kmp算法" class="headerlink" title="4.kmp算法"></a>4.kmp算法</h2><p>kmp是一种字符串匹配的算法，在大学课本里有着详细的介绍，不过不同课本中里的下标起始不一样，其思想是一样的</p>
<p>如果我们从最朴素的暴力开始考虑：</p>
<p>文本串:aababa</p>
<p>模式串:  ababa</p>
<p>我们可以用i指针便利S1，j指针便利S2，但是这样的复杂度是O（nm）</p>
<p>考虑这样一个性质:如果能记录一个既是前缀又是后缀的位置，那么如果匹配失败，不需要从头遍历，只需要将j跳转到记录的那个位置即可，最终复杂度则是O（n+m)的</p>
<p>对于学习理解kmp，我们理解下几个变量的含义</p>
<p>next数组:表示当前匹配如果失败，则j指针应当跳转的位置</p>
<p>next数组:表示为S[0,i]的真前缀与真后缀的最大相同的位数</p>
<p>而真前缀为除了本身的所有前缀都叫真前缀，除了本身的所有后缀都叫真后缀</p>
<p>比如aabaabaaa：010123452</p>
<p>a:无真前缀和和真后缀可言，所以是0</p>
<p>aa:a和a 是1	aab:真后缀和真后缀中无相同，所以是0	aaba a和a是1</p>
<p>aabaa：aa和 aa是2	aabaab: aab和aab 是3	aabaaba : aaba和aaba是4</p>
<p>aabaabaa : aabaa 和 aabaa 是5	aabaabaaa : aa和 aa是2</p>
<p>那么知道next的含义后，我们应当如何快速的去求next数组呢</p>
<p>j      i</p>
<p>0 1 2 3 4 5 6 7 8 9</p>
<p>   a a b a a b a a a </p>
<p>我们先把字符串每一位往后移一位，然后定义j初始值为0，每次我们去模拟更新next的步骤</p>
<p>1：判断是否匹配失败，如果匹配失败，j则回到上一个对应的位置</p>
<p>2.判断j右移一位是否仍然是相同的前缀与后缀</p>
<p>3.更新next数组，即为j对应的位置</p>
<p>思考一下这样为什么保证是最大的真前缀与真后缀对应了，因为j往上一个位置移动一定是最近的位置，那么如果某一个位置匹配成功，那么一定是最大。</p>
<p>模式串的next是自己与自己配对，即为自己的前缀与自己的后缀匹配，那么文本串与匹配串配对的话，则按同样的思路去配对即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s1+<span class="number">1</span>&gt;&gt;s2+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(s1+<span class="number">1</span>),m=<span class="built_in">strlen</span>(s2+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;s2[j+<span class="number">1</span>]!=s2[i])&#123;</span><br><span class="line">			j=p[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s2[i])&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		p[i]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;s2[j+<span class="number">1</span>]!=s1[i])&#123;</span><br><span class="line">			j=p[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s1[i])&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">			cout&lt;&lt;i-m+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">			j=p[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cout&lt;&lt;p[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="KMP-例题讲解"><a href="#KMP-例题讲解" class="headerlink" title="KMP 例题讲解"></a>KMP 例题讲解</h5><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF126B">CF126B Password</a> </p>
</li>
<li><p>找到既是S前缀又是S后缀又在S中间出现过（既不是S前缀又不是S后缀）的子串</p>
</li>
</ul>
<h5 id="KMP找循环节：-n-next-n"><a href="#KMP找循环节：-n-next-n" class="headerlink" title="KMP找循环节： n-next[n]"></a>KMP找循环节： n-next[n]</h5><h5 id="在字符串A中把所有字符串B删除："><a href="#在字符串A中把所有字符串B删除：" class="headerlink" title="在字符串A中把所有字符串B删除："></a>在字符串A中把所有字符串B删除：</h5><p>开一个栈，每次删除B然后指针j调到上一个位置，把未能删的位置放入栈里</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;(s1+<span class="number">1</span>)&gt;&gt;(s2+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">strlen</span>(s1+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> m=<span class="built_in">strlen</span>(s2+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j+<span class="number">1</span>]!=s2[i])&#123;</span><br><span class="line">		j=p[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s2[i])&#123;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	p[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(j&amp;&amp;s2[j+<span class="number">1</span>]!=s1[i])&#123;</span><br><span class="line">		j=p[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s2[j+<span class="number">1</span>]==s1[i])&#123;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	p1[i]=j;</span><br><span class="line">	cnt++;</span><br><span class="line">	stack1[cnt]=i;</span><br><span class="line">	<span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">		cnt-=m;</span><br><span class="line">		j=p1[stack1[cnt]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">	cout&lt;&lt;s1[stack1[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h5 id="border与失配树："><a href="#border与失配树：" class="headerlink" title="border与失配树："></a>border与失配树：</h5><p>通俗地讲，除了本身 所有前缀prei等于后缀sufi 的都称为border。</p>
<p>如何去求border呢？</p>
<p>我们先暴力地去想，如果后缀某个字符串向左平移正好是前缀那便是border，那么这样岂不是可以用kmp来求border</p>
<p>额。。。之前总结过next数组就是记录i的最长公共前后缀，那么nexti就是最长的border了</p>
<p>那么现在来考虑一个问题:给定一个字符串，以及两个位置i和j，prei和prej的最长公共border长度</p>
<p>只要在求kmp的过程中建立一颗树即可，即j的父亲为i（j和i的意义是kmp循环中两个指针i和j）。那么直接lca求出两个节点的lca，而next[lca]即是答案</p>
<p>参考代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&amp;&amp;s[j+<span class="number">1</span>]!=s[i])&#123;</span><br><span class="line">			j=p[j][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[j+<span class="number">1</span>]==s[i])&#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		p[i][<span class="number">0</span>]=j;</span><br><span class="line">		d[i]=d[j]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">21</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			p[j][i]=p[p[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="keyword">if</span>(d[x]&lt;d[y])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[p[x][i]]&gt;=d[y])&#123;</span><br><span class="line">				x=p[x][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">21</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[x][i]!=p[y][i])&#123;</span><br><span class="line">				x=p[x][i];</span><br><span class="line">				y=p[y][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;p[x][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-exkmp-待补"><a href="#5-exkmp-待补" class="headerlink" title="5.exkmp(待补)"></a>5.exkmp(待补)</h2><p>LCP (Longest Common Prefix)是指后缀数组中相邻两个后缀的最长公共前缀的长度</p>
<p>Z函数其实和kmp没有多大的关系，exkmp和kmp之间的22222222222222222222222222222222222</p>
<h2 id="6-trie树"><a href="#6-trie树" class="headerlink" title="6.trie树"></a>6.trie树</h2><p>字典树建图非常好懂</p>
<p><img src="https://oi-wiki.org/string/images/trie1.png"></p>
<p>设p[u,x]，即为u节点的第x个字符所指向的idx（位置)</p>
<p>那么通过以上图示方法进行建图，其实如果忘记字典树时 只需要想起这张图 就可以回忆起字典树的相关做法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">		<span class="type">int</span> u=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])&#123;</span><br><span class="line">			idx++;</span><br><span class="line">			son[p][u]=idx;</span><br><span class="line">		&#125;</span><br><span class="line">		p=son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">		<span class="type">int</span> u=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!son[p][u])<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">		p=son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字典树建图以及遍历没有什么难懂的，主要在于字典树的一些操作上。</p>
<h3 id="7-AC自动机"><a href="#7-AC自动机" class="headerlink" title="7.AC自动机"></a>7.AC自动机</h3><p>AC自动机在原理上，我认为是KMP与字典树的组合技。其实就是指针又一个串变成在树上匹配的一个问题。对于KMP 我认为next是记最长公共前后缀，而AC自动机的指针是记录当前串的最大公共后缀的一个东西</p>
<p>其指针的建立原理由下图讲解：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton4.png"></p>
<p>我们很容易想出，fail指针其实指的是父节点所指向的点的某个儿子，就比如4和7作为解释：4父亲3节点指向为节点0，而0中正好和儿子7之间有一个s的边，因而4的指针是指向7的</p>
<p>而这棵树是从上到下的，因此正是用bfs来存放结点的过程，fail指针的匹配我们也就边清晰起来：对于队列里的每一个结点，我们去寻找其父节点对应的某个儿子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>][i])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">            ne[ch[<span class="number">0</span>][i]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][i])&#123;</span><br><span class="line">                ne[ch[u][i]]=ch[ne[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(ch[u][i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ch[u][i]=ch[ne[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看常见的AC自动机的三个操作</p>
<p>1.有多少个不同的模式串在文本串中出现过</p>
<p>我们只需要将文本串也按照字典树的形式建出来，并在上面进行匹配。之后，我们可以暴力向上跳fail指针，从而找到对应的文本串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=ch[t][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&amp;&amp;cnt[j]!=<span class="number">-1</span>;j=ne[j])&#123;</span><br><span class="line">            ans+=cnt[j];</span><br><span class="line">            cnt[j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之所以说是暴力，是因为真的只是向上跳fail指针，因而在稠密（a…aaa）的上面还是会卡成nm的算法，这个时候考虑优化方式。我见到的一种是拓扑排序优化建图 和 建fail树找子树和，但是我做的 用到拓扑排序的题 用fail树都能过。</p>
<p>考虑以下为什么可以用fail树来优化：因为fail指针是一个单向的过程，并且不可能出现环，也就是说逆向建边后的图一定是一棵树，考虑到aaa能匹配的 aa一定也能，那么也就是说是子树的一个贡献和，因此就是求子树和的一个过程。而遍历这棵树的时间复杂度也就是O(tot)也就是节点个数，相比之下会很稳定，至少不会慢成nm。由于文本串和模式串有偶然性，所以在有些时候暴力往上跳比这样是快的。但是我们要求最慢结果的块就行了，所以fail树优化就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=ch[t][sss[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ans[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">        a[ne[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[cnt[i]])tt++;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;ans[cnt[i]]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.出现最多的字符串</p>
<p>3.每个字符串出现了 多少次</p>
<p>其实和1做法是差不多的 在一开始建树的时候，就将标记点 记录，之后fail树子树和就可以了</p>
<p>8.后缀数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, w, sa[N], rk[N &lt;&lt; <span class="number">1</span>], oldrk[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。</span></span><br><span class="line"><span class="comment">// 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, p;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) sa[i] = i, rk[i] = s[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (w = <span class="number">1</span>; w &lt; n; w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(sa + <span class="number">1</span>, sa + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">      <span class="keyword">return</span> rk[x] == rk[y] ? rk[x + w] &lt; rk[y + w] : rk[x] &lt; rk[y];</span><br><span class="line">    &#125;);  <span class="comment">// 这里用到了 lambda</span></span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">    <span class="comment">// 由于计算 rk 的时候原来的 rk 会被覆盖，要先复制一份</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i - <span class="number">1</span>]] &amp;&amp;</span><br><span class="line">          oldrk[sa[i] + w] == oldrk[sa[i - <span class="number">1</span>] + w]) &#123;</span><br><span class="line">        rk[sa[i]] = p;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rk[sa[i]] = ++p;</span><br><span class="line">      &#125;  <span class="comment">// 若两个子串相同，它们对应的 rk 也需要相同，所以要去重</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n, sa[N], rk[N], oldrk[N &lt;&lt; <span class="number">1</span>], id[N], key1[N], cnt[N];</span><br><span class="line"><span class="comment">// key1[i] = rk[id[i]]（作为基数排序的第一关键字数组）</span></span><br><span class="line"><span class="type">int</span> n, sa[N], rk[N], oldrk[N &lt;&lt; <span class="number">1</span>], id[N], px[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> oldrk[x] == oldrk[y] &amp;&amp; oldrk[x + w] == oldrk[y + w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, m = <span class="number">127</span>, p, w;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">  n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[rk[i] = s[i]];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; --i) sa[cnt[rk[i]]--] = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (w = <span class="number">1</span>;; w &lt;&lt;= <span class="number">1</span>, m = p) &#123;  <span class="comment">// m=p 就是优化计数排序值域</span></span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = n; i &gt; n - w; --i) id[++p] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">if</span> (sa[i] &gt; w) id[++p] = sa[i] - w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[key1[i] = rk[id[i]]];</span><br><span class="line">    <span class="comment">// 注意这里px[i] != i，因为rk没有更新，是上一轮的排名数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; --i) sa[cnt[key1[i]]--] = id[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(oldrk + <span class="number">1</span>, rk + <span class="number">1</span>, n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>, i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      rk[sa[i]] = <span class="built_in">cmp</span>(sa[i], sa[i - <span class="number">1</span>], w) ? p : ++p;</span><br><span class="line">    <span class="keyword">if</span> (p == n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sa[rk[i]] = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sa[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="height数组：i的后缀与前一名的后缀的最长公共前缀"><a href="#height数组：i的后缀与前一名的后缀的最长公共前缀" class="headerlink" title="height数组：i的后缀与前一名的后缀的最长公共前缀"></a>height数组：i的后缀与前一名的后缀的最长公共前缀</h3><p>不同子串的数目：n*（n+1)&#x2F;2 - sigma height[i]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="喜欢acm的zjb"
      src="https://picx.zhimg.com/v2-ff1f54ea1c0258b284145044aafd19a2_l.jpg?source=32738c0c">
  <p class="site-author-name" itemprop="name">喜欢acm的zjb</p>
  <div class="site-description" itemprop="description">快快乐乐就好了</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/z1z1-65" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;z1z1-65" rel="noopener" target="_blank"><i class="gratipay fa-fw"></i>知乎</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/184701384?spm_id_from=333.1007.0.0" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;184701384?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="gratipay fa-fw"></i>B站</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://baidu.com/" title="https:&#x2F;&#x2F;baidu.com" rel="noopener" target="_blank">很多事情可以靠百度</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-11 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">喜欢acm的zjb</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  

</body>
</html>
